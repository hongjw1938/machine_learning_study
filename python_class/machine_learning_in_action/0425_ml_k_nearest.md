## 2장. K-최근접 이웃 알고리즘(k-nearest-neighbor algorithm)
---------------------------------------------------
>###    2.1 거리 측정을 이용해 분류하기
        * k-최근접 이웃 알고리즘
            - 장점 : 높은 정확도, 오류 데이터에 둔감, 데이터에 대한 가정 없음
            - 단점 : 계산 비용이 높음, 많은 메모리 요구
            - 적용 : 수치형 값, 명목형 값
        * 거리 측정(distance measurement)
            * 로맨스 영화 / 액션 영화 분류 가정
                - 키스, 발차기 장면 출현 횟수에 따른 분포 그리기
                - 기존의 여러 영화를 분류, 새로운 표본이 추가된 경우 해당 영화와 기존 분류된 영화들과의 거래 계산
                - 거리를 내림차순으로 정렬해 가장 가까운 k개의 영화를 찾는다. k=3을 가정
                - k개의 영화에서 다수결로 뽑힌 것으로 새로운 영화의 분류가 결정됨
        * kNN의 일반적 접근 방법
            1. 수집 : 모든 방법
            2. 준비 : 수치형 값(거리 계산)
            3. 분석 : 모든 방법
            4. 훈련 : 적용하지 않음
            5. 검사 : 오류율 계산
            6. 사용 : 응용프로그램은 입력 데이터를 받아 구조가 있는 수치형 값으로 출력하는 데 필요, 입력 데이터를 갖고 kNN알고리즘을 실행해 분류 항목 결정 
        1. 파이썬으로 데이터 불러오기
            - numpy 모듈 및 operator모듈 사용
        2. 알고리즘 실행
            - 코드 참조
            - 데이터 집합에 있는 모든 측정값을 반복한다.(for 반복)
            - 현재 측정값과 데이터셋 집합의 element와의 거리를 계산
            - 오름차순 거리 정렬
            - k개의 아이템 추출(거리가 짧은 순)
            - k개의 아이템에서 가장 많은 분류 항목(label) 찾기
            - 가장 많은 분류 항목을 반환
            * tile함수
                - Construct an array by repeating A the number of times given by reps.
                - 즉, 인자로 받은 reps값(차원)에 맞추어 배열을 반복해 형성.
                - np.tile(A, reps)와 같이 인자를 구성
                - A는 인자로 넣을 배열.(array_like)
                - reps는 배열을 반복할 횟수. 각 axis에 대해 반복.(array_like)
                예시)
                >>> a = np.array([0, 1, 2])
                >>> np.tile(a, 2)
                >>> array([0, 1, 2, 0, 1, 2])
                >>> np.tile(a, (2, 2))
                >>> array([[0, 1, 2, 0, 1, 2],
                        [0, 1, 2, 0, 1, 2]])
                >>> np.tile(a, (2, 1, 2))
                >>> array([[[0, 1, 2, 0, 1, 2]],
                        [[0, 1, 2, 0, 1, 2]]])
                >>> c = np.array([1,2,3,4])
                >>> np.tile(c,(4,1))
                    array([[1, 2, 3, 4],
                          [1, 2, 3, 4],
                          [1, 2, 3, 4],
                          [1, 2, 3, 4]])
            * numpy.argsort()함수
                - 반환값: 배열이 정렬되었을 때의 인덱스 배열(ndarray, int)
                - 마지막 축을 기준으로 정렬(기본값) https://docs.scipy.org/doc/numpy/reference/generated/numpy.argsort.html
        3. 분류기 검사하기
            - 오류율 검사
>###    2.2 kNN을 이용해 데이트 사이트 만남 주선 개선
            Collect:
                텍스트 파일 제공됨
            Prepare:
                파이썬에서 텍스트 파일 파싱
            Analyze:
                Matplotlib을 사용하여 데이터의 2차원 플롯 생성
            Train:
                kNN 알고리즘에는 훈련이 필요없음
            Test:
                헬렌이 준 데이터 중 일부를 테스트 데이터로 사용하는 함수 작성
                테스트 데이터는 비테스트 데이터와 구별
                예측된 클래스가 실제 클래스와 일치하지 않으면 오류
            Use:
                헬렌이 입력한 몇몇 값을 바탕으로 헬렌이 좋아하는 상대인지 예측하는 간단한 명령행 프로그램 작성
        1. 텍스트 파일 데이터 구문 분석
            - 연간 항공 마일리지 수
            - 비디오 게임 시간 비율
            - 주당 아이스크림 소비량
            - 약 1000개의 항목.
            file2matrix 함수
                텍스트 파일의 데이터를 분류기가 사용할 수 있는 형태로 변환
                입력: 파일 이름
                출력: 훈련 데이터(행렬), 클래스 레이블(벡터)
            * readLine함수는 파일을 다 읽고 첫 부분으로 포인터를 돌리지 않는다. 다시 읽고 싶은 경우 open으로 파일을 다시 열어야 한다.
            * numpy.vstack
                - numpy 배열들을 입력받아 수직으로 쌓은 후 numpy 배열 반환
                - 첫 번째 축(차원)을 제외한 모든 축의 크기가 같아야 함
                ex)
                    a = np.array([1, 2, 3])
                    b = np.array([2, 3, 4])
                    c = np.array([3, 4, 5])
                    np.vstack((a, b, c))
                    >>> array([[1, 2, 3],
                               [2, 3, 4],
                               [3, 4, 5]])
        2. 매스플롯라이브러리로 scatter 플롯 생성
        3. 수치 데이터 정규화
            - 연간 항공 마일리지 수 항목의 효과가 가장 크게 나타난 것을 알 수 있다.
            - 그러나 정말 해당 특징이 그만큼의 중요도가 있는가?
            - 헬렌은 세 가지 특징이 다 같은 정도의 중요도를 갖는다고 생각한다.
            - 하지만 연간 항공 마일리지 수는 다른 특징에 비해 값 자체가 크다.
            - 즉, 연간 항공 마일리지 수 특징의 값이 두 점 사이의 거리에 영향을 크게 미친다.
            - 즉, 연간 항공 마일리지 수의 중요도가 높다.
            * 정규화 : 값의 범위를 [0, 1] 또는 [-1, 1]로 변환
        4. 검사
            * 기계 학습 알고리즘의 정확도
                - 데이터의 90% 정도를 분류기(classifier) 학습에 사용
                - 나머지 10%를 분류기의 정확도를 구하기 위한 테스트 데이터로 사용
                - 이 10% 데이터는 임의로 선택
                - 우리가 사용하는 데이터는 특정 순서로 저장된 것이 아니므로 처음 10% 또는 마지막 10%를 테스트 데이터로 선택하는 것이 임의로 10% 선택하는 것과 다를 바 없음
            * 에러율(error rate)
                - error rate = 잘못 분류된 데이터 수 / 전체 데이터 수
                - error rate = 0 ==> 완벽한 분류기
                - error rate = 1.0 ==> 항상 잘못 분류하는 분류기
        5. 유용한 시스템 만들기
            - 실질적으로 사람을 분류하기 위한 코드 작성
            - 얼마나 좋아하게 될지 판단해줌
            